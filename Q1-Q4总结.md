在表述具体产出时，顺带把kr4有关bug率之类的也不表述出来。

雅典娜v1.2.0，场景配置，客户会话，时间配置

难点：与常规antd表单校验不同，除了加入后端校验时机，还需要联动是否勾选，以及联动判断是否有修改内容，来判断保存按钮的状态。对我个人来说，当时这里，还是比较容易出bug，但遵循okr中自测细致的要求，还是做到了这期bug为0。

客户会话中有个历史bug。

雅典娜v1.3.2, bug为1(用户体验方式上)

c端重构2.1.0

**ui组件：**

全局配置组件-》入口location，区分pc/mobile

页面组成：header/body/footer

**header：**

Pc:无header

M：皮肤，位置同现在，内容同雅典娜im名称+在线客服设置

**body：**



**footer:**(重点和软盘相关的显示)

pc：

textera+popover+tabbar+input（图片、文件）?(气泡卡片放表情包,宽度沾满，间距自适应)。

Mobile:

textera+下部的drawer+input（相册、拍摄）



## Q1总结

1. 按chunk划分，资源能缓存更久了(非修改文件，hash不变)
2. 主题会把pc\m\weixi，css打包在一起，不好拆分css（从资源角度，他们是不同的，就像pc组件和m组件不一样，拆开也便于维护）。主题就是把less变量和每一个less文件合并，它是不关心是pc还是m文件的less，最后pc和m就在一起了。

pc\m\bigPc, 一开始使用的主题概念，是个plugin插件，但它会把所有样式打包到一个文件下。

首先考虑的是，想拆分开css，那就把每个组件的less，import到对应的主题css下，主动告诉它应该在pc\m\bigPc打包哪些文件，结果发现会报Url(../*img) not found in Antd.style，就很奇怪，为啥写在css里的background会被引用在antd的样式里，后来发现plugin是为了从less变量层面区分主题，所以它实现是把每个less变量文件和每一个less文件合并在一起，然后打包，所以如果项目引用的组件如果自身import了less文件，那它也会合并进去，包括import进变量文件的所有css。

所以后来我们考虑主题确实目前没有用了，所以就去掉主题plugin好了。加上MiniCssExtractPlugin，配置好loader，让webpack自动打包。然而我们的场景是，关于body体(也就是消息展示这块)，三端的组件功能是大致相同的，所以只有css不同。我们不能写两个相同组件文件(js是相同的)，然后只让import的 css不同，通过use agent判断导入不同组件。所以如果能动态导入less就好了，通过ua判断，导入对应的less这样，但是import()方法不支持less的导入，准确说，import方法需要一个有export的文件支持，而less是不能的。所以最后拆分就是，对msglist这个三端组件大致相同，css不太一致的组件，写三个文件，同一个组件导入不同的less。然后通过ua判断使用哪个文件组件。这样的好处是，不仅拆开了css而且不用在逻辑里写hook判断应该使用哪个classname，因为即使代码写入相同的classname，因为less引入不同，只有对应less被引入了。

而且用了react.lazy对部分组件异步导入。像之前header的pc/m虽然用ua区分了，但实际上




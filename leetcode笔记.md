动态规划

**动态规划问题的一般形式就是求最值**。比如求**最长**递增子序列呀，**最小**编辑距离呀等等。

**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

特点：

**存在「重叠子问题」**

一定会**具备「最优子结构」**

**正确的「状态转移方程」**

当前状态和上一个的状态相关

解法：

1、**确定 base case**

2、**确定「状态」，也就是原问题和子问题中会变化的变量**

3、**确定「选择」，也就是导致「状态」产生变化的行为**

4、**明确 `dp` 函数/数组的定义**。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
       # dp函数
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```



### Tag

---

#### Array

**1. 最大子序和(Easy)**

1. 两层暴力便利
2. 动态规划

动态规划

1. 确定base case：Dp(0) = nums[0]
2. 确定状态：num
3. 确定选择：for const num of nums
4. 明确dp：dp(i) = max(dp(i - 1) + nums[i] / dp(i - 1), nums[i])

**2. 最大回文字串**

1. 两层暴力便利
2. 动态规划

动态规划

1. 确定状态：`dp[i][j]`: 字符串i到j是否回文。

1. 转移方程：dp[i]\[j] = dp[i+1]\[j-1] && s[i] === s[j]
   1. Dp[i+1]\[j-1] 代表上一个字串是回文的
   2. s[i] === s[j]代表当前是回文的
2. 特殊：j - i < 2，数量小于2，长度为0/1

**3. 爬楼梯**

动态规划

1. 确定状态：dp[n]: 到当前层楼梯有多少种方法
2. 转移方程：dp[n] = dp[n - 1] + dp[n - 2]
   1. dp[n - 1]代表上一次是一步过来的，n-2代表两步
3. 特殊：n === 1 || n === 2
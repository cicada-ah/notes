

useState改变时，函数重新执行，会让组件内大量的引用类型的地址发生重新创建复制，地址发生变化，会触发引用子组件的更新，手动维护是否耗时耗力，而且大量usememo

usecallback充斥在组件内，同时新建引用类型时，需要承担是否后续会被子组件引用，而心智上需要负担某时刻发生的更新是否符合预期。



为什么需要使用react-context，因为mobx-react需要支持hook的更新策略

Mobx 是个数据驱动器

mobx+模版解析+dom操作 = vue1.  new Watch 绑定在每一个dom上 

mobx+模版解析+vdom+dom操作=vue2 new Watch绑定在每一个vdom上 监控颗粒度

mobx+模版解析+

而数据管理能力，是它数据驱动能力，加能够定义组件外部的能力提供的。

数据管理 ！== mobx

局部数据状态可以和ui写在一个文件里

![image-20210126160809057](/Users/bjhl/Library/Application Support/typora-user-images/image-20210126160809057.png)

所以复杂组件勤写usecallback usememo准没错



context 时:

Vue & react

一种是以 Vue 为代表的 mutable + change tracking。即可变的数据结构，配合变更追踪，触发更新函数。

另一种是以 React 为代表的 immutability + referential equality testing。即不可变的数据结构，配合反复执行的渲染函数，以及在函数执行过程中，通过数据的引用相等性判断，找出变更部分，只应用变化的部分到 UI 上。

https://zhuanlan.zhihu.com/p/79245530

## 状态管理

https://juejin.cn/post/6844903848255946766#heading-4

现在的前端框架，包括 React 的一个核心思想就是**数据驱动视图**, 即`UI = f(state)`. 这种开发方式的变化其实得益于 Virtual-DOM, 它使得我们不需要关心浏览器底层 DOM 的操作细节，只需关心‘状态(state)’和‘状态到 UI 的映射关系(f)’. **所以如果你是初学者，不能理解什么是‘数据驱动’, 还是不推荐继续阅读文章下面的内容**。

但是随着 `state` 的复杂化, 框架现有的组件化方式很难驾驭 `f`(视图的映射关系变得复杂, 难以被表达和维护); 或者相关类型的应用数据流本来就比较复杂, 组件之间的交互关系多样，本来难以使用`UI = f(state)`这种关系来表达; 或者应用的组件状态过于离散，需要统一的治理等等. 我们就有了状态管理的需求.

状态管理最基础的解决方式就是分层，也就是说和传统的 `MV*` 模式没有本质区别, 主流状态管理的主要结构基本都是这样的:

![img](https://user-gold-cdn.xitu.io/2019/5/21/16ada5c029ad8bad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

他们基本都包含这些特点:

- **分离视图和状态**. 状态管理器擅长状态管理，所以他们一般会将应用状态聚合在一起管理，而视图退化为贫血视图(只关注展示)，这样就可以简化`f`映射关系, 让`UI = f(state)`这个表达式更彻底
- **约束状态的变更**。Redux 要求通过`dispatch+reducer`, mobx 要求数据变更函数使用`action`装饰或放在[`flow`](https://mobx.js.org/best/actions.html)函数中，目的就是让状态的变更根据可预测性
- **单向数据流**。数据流总是按照 Store -> View -> Store 这样的方式流动, 简化数据流



但是, React 的状态管理方案太多了，选择这些方案可能会让人抓狂，你需要权衡很多东西:

- 面向对象还是函数式还是函数响应式?
- 单 Store 还是多 Store？
- 不可变数据还是可变数据？
- 写代码爽还是后期维护爽?
- 自由还是约束？
- 强类型还是弱类型？
- 范式化数据还是非范式化？
- React 原生还是第三方?
- ...



## 你不需要复杂的状态管理

当你的应用有以下场景时，就要开始考虑状态管理:

- 组件之间需要状态共享。同一份数据需要响应到多个视图，且被多个视图进行变更
- 需要维护全局状态，并在他们变动时响应到视图
- 数据流变得复杂，React 组件本身已经无法驾驭。例如跨页面的用户协作
- 需要统一管理应用的状态。比如实现持久化，可恢复，可撤销/重做
- ...



redux

几乎需要把所有state 都放在 redux中以保证 persistent state。Single store带来的问题是 你需要花费很多时间去思考怎样去合理的 structure 你的 store

样板代码过长，更新优化复杂，单个 Store 缺少模块概念，自身不支持异步



 context

优点：

1.react原生管理方式

2.简单、易用

3.普通hook，Dev tool 上可调试

问题：

1.需要关注性能问题，需要将状态按使用场景拆分[new 很多 context，引用时会书写很多冗余]

2.状态不断提升，最后可能就是context * n（App）

3.状态只能在整个组件内部使用，毕竟是hook



Context在状态共享不那么频繁，项目不那么庞杂的情况下，还是很好用的，否则可能问题1，就需要花费大量精力，所以context在官方的设计目的是为了共享对于一个组件树而言的”全局”状态。



hooks+mobx

Mobx 的优缺点

经过上述分析，很自然的可以得到 Mobx 的优点：

- 简洁
- 没有样板代码
- 轻松的异步
- 通过 `makeAutoObserver` 自动识别动作、`computed` 等 
- 灵活
- 高性能（局部更新），拆分越多性能越高.jpg
- ......

Mobx 最主要的缺点：

- 体积较大
- 一些写法不够优雅
- 灵活
- 不兼容concurrent mode （a，b两个组件被一个数据依赖收集，当a发生变化时，b还没有render，这会破坏react的调度。@action是为了防止多次调用修改状态的操作）



1. 怎么组织全局状态
2. 怎么管理局部mobx的相互调用

import or property

1. 怎么组织hooks

https://www.zhihu.com/question/357020049/answer/967850199

1. 怎么维护子组件的精确更新

useObserver



## 为什么要学习函数式编程？

而当我们在进行应用程序开发时，应该遵循以下原则

- 可拓展性 —— 是否需要不断的重构代码来添加新的功能
- 可重用性 —— 是否写了很多重复的代码
- 易模块化 —— 当更改了一个文件，其他文件是否会受到影响
- 易于测试 —— 函数是否是便于测试的
- 易推理性 —— 代码是否晦涩难懂

而函数式编程的出现，恰好也解决了这些开发中的痛点。

函数式编程还有诸多好处，例如

- 函数式编程可以抛弃this
- 打包过程中可以更好的利用tree shaking 过滤掉无用代码
- 方便测试，方便并行处理
- 有很多库可以帮助我们进行函数式编程开发：比如lodash、underscore、ramda

满足纯函数的两个条件：
1.函数返回结果只依赖它的参数。
2.函数执行过程中不会对外产生可观察的变化。

https://juejin.cn/post/6916815364928045070



#### 状态管理的本质是什么

1. **数据的共享** 在 React 应用中，在组件间优雅的共享一些数据并非易事，而各种状态管理工具都给出了自己对“数据共享”的标准方案
2. **逻辑的组织** 状态不单单是数据项的堆砌，更重要的是把各项数据之间的逻辑、数据与其他系统模块之间的互动逻辑进行组织，例如 A 需要在用户点击按钮时发生变化，而 B 又需要在 A 变化时跟着变化（可能是同步的也可能是异步的）

##### 数据共享：局部还是全局？

react中，最简单的方式就是把数据共享设计为全局性（redux/部分context用法），于是常规开发中的技术方案就是：组件内状态+全局(useState+redux/context)。然而组件内状态的对立面不是共享状态，所以内部状态的对立面不单是全局状态，而是外部状态。外部状态即是两方面：1.既属于本身 2. 又共享他人。所以从新建立共享状态的认知应该是：**全局共享状态+局部共享状态**。

明明状态和update属于当前组件，却又不得不妥协给上级组件再props下来。

局部优点：

1. **自洽性** 局部组件拥有自己的状态管理相关的完整逻辑，在组件层面上逻辑闭环。
2. **减少全局依赖** 降低对全局的依赖，没有创建在全局状态的心理负担。
3. **灵活，易于维护、问题排查** 局部状态定义在局部组件，排查和维护更聚焦问题点。
4. **解耦状态** 把不相关且分散的状态定义在全局自然是提高耦合的。

##### 逻辑组织：hooks

逻辑组织是把"一块有逻辑关联性的代码，组织在一起"，而组织在一起是为了易于代码的阅读(利于开发、维护、排查)，提高复用性。在class阶段复用性困难，组件复杂后，难以理解，同一个生命周期存在太多不相关的逻辑。而hook出现后中对关联部分有了更好的组织能力，比如可以写很多useEffect，不同的effect处理相关的逻辑，逻辑割裂性被降低。（事件监听,移除/添加写在不同人的生命周期，然而却是一个逻辑相关的）

尽可能的降低使用useState、useEffect，而是把相关逻辑封装为一个个hook。而组件内部状态就是多个hook堆积而成。而多个hook关联部分应该抽成更底层的通用性hook。类似函数或者组件的意思，把一块逻辑放在一起。

**通用性 hook + 业务性 hook **



最终管理方案：

**全局状态+局部状态+内部状态**

全局状态，进入系统不需要切换到任何组件即可共享的。

最终技术方案：

**mobx(全局)+mobx（局部）+hooks**

utils -> 功能 -> 业务 hook



#### mobx

1. 尽量用observer/ <Observer>包裹组件，observer封装了memo，只在1. props发生变化，2. observable发生变化时，才会re-render。
2. 退出组件清空mobx里的局部数据，mobx思想是分散式状态，但比较保存数据到全局了。
3. 凡是异步里用到了修改mobx的方法，要注意cancel掉。context也有这个问题
4. Mobs 遵守react‘异步’更新，批处理更新，但是状态修改是同步的
5. _代表共享数据 ,$代表局部(hook之间), 状态共享后，最大的问题是，你不知道这个状态在哪里被修改了，需要一遍遍检查的心智负担，这也是vue的缺点，在大型项目，修改状态的方式太灵活。

#### hooks

1. 尽量多使用useMemo + useCallback,一方面避免react在render阶段进行不必要的计算，另一方面可能能避免一些不必要的commit（https://codesandbox.io/s/compassionate-pasteur-otc47?file=/src/App.js如2所述）。
2. 解决compoment diff的问题，hook中由于函数会被重新创建，所以hook内部创建的函数以标签的形式（<Render>），react diff会因为引用不同而移除dom在添加。而表达式形式不会。class类型的也不会，因为不会re-run函数。如果usecallback需要依赖渲染，为了不改变引用，可以使用useRef（react 手动维护更新，在心智上的负担啊～）
3. 原始hook状态更新方式，应该使用immer来结合mutable+immutable，简化更新操作，增加可读性（更符合js自然操作的方式，对外mutable，对内immutable）。
4. 相关state合并为一个对象，粒度变粗，减少代码冗余；不相关的独立，粒度变细，增加逻辑组合、复用性。(在很多时候都是由于代码冗余造成的问题)
5. 尽量减少直接使用usestate，直接书写usestate基本是没有意义的，约等于定义了一个变量，通常这个变量是需要有变化逻辑的。
6. 相关性逻辑封装在一起，业务大多是数据状态+对应的function+effect(副作用)，将这一系列强相关的逻辑尽量组合在一起。（高内聚、低耦合）
7. 减少effect依赖数量（拆分hook）
8. 尽量不用引用类型作为effect的更新依赖，而是obj.xxx这种基本类型，如果需要判断对象是否变化，应该通过深比较判断是否需要变化新的引用（后端返回的params，深比较返回true/false）
9. 利用好useRef（持久化储存场景、异步场景、渲染无关场景（不需要用setState时），打破闭包壁垒）usePersistFn,(https://codesandbox.io/s/patient-cookies-hjrv9?file=/src/Child.js).需要保存频繁修改useRef尽量在effct里（兼容concurrent mode，多次调用render表现不一致的情况）https://frontarm.com/daishi-kato/use-ref-in-concurrent-mode/ (在render的时候不能有副作用操作，副作用操作放在effect里) （eg:https://codesandbox.io/s/reverent-dhawan-i6nlc?file=/src/App.js:661-671）
10. 封装useRequest，避免重复的loading、effect
11. ... 参考一些hook库的实现，
    1. 依赖相同的hook，应该合并，减少开销。
    2. useref不要丢给外部修改，而是在一个封闭的hook内修改，把方法pu出去
    3. useMemo,useCallback的hook要确保返回的函数只创建一次，不然外部在effect调用这个函数，会产生闭包问题。(通常在内部，通过ref或者setstate函数的形式，去掉依赖)



大部分时候就是在用户体验、和开发、维护上的取舍，统一用usecallback解决引用类型的问题，是为了牺牲一部分用户体验，换取开发的效率。

(Ppt)我们无论是开发还是维护，一个组件都是最上层的，所以组件里内容除了把变量和相关逻辑组合外，也应该是语义化的，当定义一个变量，一定是为了操作它，而变量和操作的方法就应该组织成一个语义化的描述。这样一层层的搭建hook。最后把一系列语义化的hook写在组件里。之前hook的写法我认为还是沿用了class类时期的思路。



状态和对应的操作方法以及生命周期组织再一起，在把状态和方法暴露出来。

当暴露的方法足够多了，用dispatch的方式



虽然并不清楚并发模式的具体代码实现，但可以肯定的是目前的并发模式，是打断当前的render执行高优任务的render，这是为了解决复杂交互场景的性能，所以现在大多数场景的性能，并不能得到改善，使用react还是需要技巧，注意一些优化细节，所以react把优化方式交给用户来控制，看似更灵活，实则不仅开发难度上升，而且还需要写一些usecallback、memo啥的，确实是有一些不厚道，并不是每一个开发者都是fackbook前端的水准，而且国内业务任务还是比较重的，并不是有很多精力投入到代码重构里，大半年学习、使用的感受就是这样的，document.title=a就会改变，才是符合js开发的自然，并不是被知乎、文章啥洗脑的，相信大家也能有部分感受。不过这可能也是理论上的，因为实际想想，hook比较灵活，便底层，更新时可控，vue封装度高，api多，更新可能会找不到哪里导致出现了bug。



React Hooks 你真的用对了吗？

https://zhuanlan.zhihu.com/p/85969406?utm_source=zhihu&utm_medium=social&utm_oi=27175365378048

React Hooks(二): useCallback 之痛

https://zhuanlan.zhihu.com/p/98554943

React Hooks(四): immutable

https://zhuanlan.zhihu.com/p/163590288

重构目的

减少维护成本、简化开发负担、增强开发体验、优化性能、bug排查快速



---

其实做了这么多，这次mobx+react 只是繁琐的实现了一半的vue3，用mobx解决hook函数多次调用、减少usecallback的使用、降低闭包问题、手动声明依赖、精准更新、降低GC（ vue hook只调用一次做收集作用，而react中需要反复调用然后gc），这些本来就是vue3里的hook所具备的，之所以是一半，是因为只有共享变量用到了mobx，组件本身的还是交给了react。所以vue3的hook确实优于react hook。